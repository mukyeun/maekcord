// src/components/QueueDisplay/QueueDisplay.jsx
import React, { useState, useEffect, useCallback } from 'react';
import { Modal, List, Typography, Space, Alert, Switch, Radio, Input, Drawer, Descriptions, Tag, Tabs, message, Button } from 'antd';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  SoundOutlined, 
  UserOutlined, 
  ClockCircleOutlined,
  AudioMutedOutlined,
  SearchOutlined,
  PhoneOutlined,
  CalendarOutlined,
  MedicineBoxOutlined
} from '@ant-design/icons';
import * as queueApi from '../../api/queueApi';
import { wsClient } from '../../utils/websocket';
import { speak, initSpeech, announcePatientCall, getVoices, speakText, isSpeechSynthesisSupported, safeSpeak } from '../../utils/speechUtils';
import { soundManager } from '../../utils/sound';
import styled from 'styled-components';  // styled-components import Ï∂îÍ∞Ä

const { Title, Text } = Typography;
const { Search } = Input;

// ÏÉÅÌÉúÎ≥Ñ ÏÑ§Ï†ï
const STATUS_CONFIG = {
  waiting: { 
    color: 'gold', 
    text: 'ÎåÄÍ∏∞Ï§ë', 
    icon: <ClockCircleOutlined /> 
  },
  called: { 
    color: 'green', 
    text: 'Ìò∏Ï∂úÎê®', 
    icon: <SoundOutlined /> 
  },
  consulting: { 
    color: 'blue', 
    text: 'ÏßÑÎ£åÏ§ë', 
    icon: <UserOutlined /> 
  },
  done: { 
    color: 'default', 
    text: 'ÏôÑÎ£å', 
    icon: null 
  }
};

// Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÑ§Ï†ï
const listItemVariants = {
  hidden: { opacity: 0, x: -20 },
  visible: { opacity: 1, x: 0 },
  exit: { opacity: 0, x: 20 }
};

// ‚úÖ 1. styled-components Î®ºÏ†Ä ÏÑ†Ïñ∏
const StyledCard = styled.div`
  padding: 16px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  margin-bottom: 16px;
`;

const QueueItem = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px;
`;

const WaitingTime = styled.span`
  color: ${props => props.isLong ? '#ff4d4f' : '#8c8c8c'};
  font-size: 14px;
`;

const StatusBadge = styled.span`
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  background-color: ${props => {
    switch (props.status) {
      case 'waiting': return '#1890ff';
      case 'called': return '#faad14';
      case 'consulting': return '#52c41a';
      default: return '#d9d9d9';
    }
  }};
  color: white;
`;

// ‚úÖ 2. motion components ÏÑ†Ïñ∏
const MotionCard = motion.create(StyledCard);

const QueueDisplay = ({ visible, onClose }) => {
  const [queueList, setQueueList] = useState([]);
  const [loading, setLoading] = useState(false);
  const [lastCalledPatient, setLastCalledPatient] = useState(null);
  const [error, setError] = useState(null);
  const [isSoundEnabled, setIsSoundEnabled] = useState(true);
  const [filterStatus, setFilterStatus] = useState('all');
  const [searchText, setSearchText] = useState('');
  const [selectedPatient, setSelectedPatient] = useState(null);
  const [isDrawerVisible, setIsDrawerVisible] = useState(false);
  const [isRealtime, setIsRealtime] = useState(true);
  const [isVoiceEnabled, setIsVoiceEnabled] = useState(() => {
    return localStorage.getItem('queueVoiceEnabled') !== 'false' && isSpeechSynthesisSupported();
  });
  const [activeTab, setActiveTab] = useState('1');

  // ReceptionDashboardÏóêÏÑú ÌÖåÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞Î°ú ÌÅê ÏÉùÏÑ±
  const testPatients = [
    {
      _id: '1',
      patientId: {
        basicInfo: {
          name: 'ÍπÄÌôòÏûê',
          phone: '010-1234-5678',
          visitType: 'Ï¥àÏßÑ'
        },
        symptoms: ['ÎëêÌÜµ', 'Ïñ¥ÏßÄÎü¨ÏõÄ']
      },
      status: 'waiting',
      queueNumber: '001',
      createdAt: new Date().toISOString()
    },
    {
      _id: '2',
      patientId: {
        basicInfo: {
          name: 'Ïù¥ÌôòÏûê',
          phone: '010-2345-6789',
          visitType: 'Ïû¨ÏßÑ'
        },
        symptoms: ['Î≥µÌÜµ']
      },
      status: 'waiting',
      queueNumber: '002',
      createdAt: new Date(Date.now() - 1000 * 60 * 30).toISOString() // 30Î∂Ñ Ï†Ñ
    }
  ];

  // localStorageÏóêÏÑú ÏÜåÎ¶¨ ÏÑ§Ï†ï Î∂àÎü¨Ïò§Í∏∞
  useEffect(() => {
    const savedSoundSetting = localStorage.getItem('queueSoundEnabled');
    if (savedSoundSetting !== null) {
      setIsSoundEnabled(savedSoundSetting === 'true');
    }
  }, []);

  useEffect(() => {
    const savedVoiceSetting = localStorage.getItem('queueVoiceEnabled');
    if (savedVoiceSetting !== null) {
      setIsVoiceEnabled(savedVoiceSetting === 'true');
    }
  }, []);

  // ÏÜåÎ¶¨ ÏÑ§Ï†ï Ï†ÄÏû•
  const handleSoundToggle = (checked) => {
    setIsSoundEnabled(checked);
    localStorage.setItem('queueSoundEnabled', checked.toString());
  };

  const handleVoiceToggle = (checked) => {
    if (checked && !isSpeechSynthesisSupported()) {
      message.warning('Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî ÏùåÏÑ± Ìï©ÏÑ±ÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
      return;
    }

    setIsVoiceEnabled(checked);
    localStorage.setItem('queueVoiceEnabled', checked);
    
    // ÏùåÏÑ± ÌÖåÏä§Ìä∏
    if (checked) {
      try {
        safeSpeak('ÏùåÏÑ± ÏïàÎÇ¥Í∞Ä ÏºúÏ°åÏäµÎãàÎã§.')
          .catch(error => console.error('ÏùåÏÑ± ÌÖåÏä§Ìä∏ Ïã§Ìå®:', error));
      } catch (err) {
        console.error('ÏùåÏÑ± Ìï©ÏÑ± ÏÇ¨Ïö© Î∂àÍ∞Ä', err);
        message.error('ÏùåÏÑ± Ìï©ÏÑ±ÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
        setIsVoiceEnabled(false);
        localStorage.setItem('queueVoiceEnabled', 'false');
      }
    }
  };

  const calculateWaitingTime = (createdAt) => {
    const waitingTime = Math.floor((Date.now() - new Date(createdAt)) / 1000 / 60);
    return waitingTime < 60 
      ? `${waitingTime}Î∂Ñ`
      : `${Math.floor(waitingTime / 60)}ÏãúÍ∞Ñ ${waitingTime % 60}Î∂Ñ`;
  };

  const playCallSound = () => {
    if (isSoundEnabled) {
      soundManager.playDingDong();
    }
  };

  const handlePatientCalled = useCallback(async (patient) => {
    try {
      if (!patient?.patientId?.basicInfo?.name) return;
      
      if (isVoiceEnabled && isSpeechSynthesisSupported()) {
        await safeSpeak(`${patient.patientId.basicInfo.name}Îãò ÏßÑÎ£åÏã§Î°ú Îì§Ïñ¥Ïò§ÏÑ∏Ïöî.`);
      }
    } catch (e) {
      console.error('ÏùåÏÑ±Ìï©ÏÑ± Ïã§Ìå®:', e);
    }
  }, [isVoiceEnabled]);

  // ÎåÄÍ∏∞ Î™©Î°ù Ï°∞Ìöå
  const fetchQueueList = async () => {
    try {
      setLoading(true);
      console.log('üìã QueueDisplay - ÎåÄÍ∏∞ Î™©Î°ù Ï°∞Ìöå ÏãúÏûë');
      const response = await queueApi.getTodayQueueList();
      console.log('üîç QueueDisplay - ÏÑúÎ≤Ñ ÏùëÎãµ:', response);

      // ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
      let queueData;
      if (response && Array.isArray(response.data)) {
        queueData = response.data;
      } else if (Array.isArray(response)) {
        queueData = response;
      } else if (response?.data?.data && Array.isArray(response.data.data)) {
        queueData = response.data.data;
      } else {
        throw new Error('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÎåÄÍ∏∞ Î™©Î°ù Îç∞Ïù¥ÌÑ∞');
      }

      console.log('‚úÖ QueueDisplay - Ï≤òÎ¶¨Îêú ÎåÄÍ∏∞ Î™©Î°ù:', queueData);
      setQueueList(queueData);
    } catch (error) {
      console.error('‚ùå QueueDisplay - ÎåÄÍ∏∞ Î™©Î°ù Ï°∞Ìöå Ïã§Ìå®:', error);
      message.error('ÎåÄÍ∏∞ Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
      setQueueList([]);
    } finally {
      setLoading(false);
    }
  };

  // WebSocket Î©îÏãúÏßÄ Ï≤òÎ¶¨
  const handleWebSocketMessage = useCallback((data) => {
    console.log('üì® QueueDisplay - WebSocket Î©îÏãúÏßÄ ÏàòÏã†:', data);
    
    if (data.type === 'QUEUE_UPDATE' && Array.isArray(data.queue)) {
      console.log('üìã QueueDisplay - ÌÅê Î™©Î°ù ÏóÖÎç∞Ïù¥Ìä∏:', data.queue);
      setQueueList(data.queue);
    } else if (data.type === 'PATIENT_CALLED') {
      console.log('üìû QueueDisplay - ÌôòÏûê Ìò∏Ï∂ú Ïù¥Î≤§Ìä∏:', data);
      
      // Ìò∏Ï∂úÎêú ÌôòÏûê Ï†ïÎ≥¥ ÏÑ§Ï†ï
      if (data.patient) {
        setLastCalledPatient(data.patient);
        
        // ÏùåÏÑ± ÏïàÎÇ¥ Ïã§Ìñâ
        if (isVoiceEnabled && isSpeechSynthesisSupported()) {
          handlePatientCalled(data.patient);
        }
      }
      
      // ÌôòÏûê Ìò∏Ï∂ú Ïãú Î™©Î°ù ÏÉàÎ°úÍ≥†Ïπ®
      fetchQueueList();
    } else if (data.type === 'PONG' || data.type === 'pong' || data.type === 'CONNECTED') {
      // Ïó∞Í≤∞ ÌôïÏù∏ Î∞è ping-pong Î©îÏãúÏßÄ - Î¨¥Ïãú
      console.log('üîó WebSocket Ïó∞Í≤∞ ÌôïÏù∏ Î©îÏãúÏßÄ:', data.type);
    } else {
      console.log('‚ö†Ô∏è QueueDisplay - Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ WebSocket Î©îÏãúÏßÄ:', data);
    }
  }, [isVoiceEnabled, handlePatientCalled]);

  // WebSocket Ïó∞Í≤∞ ÏÑ§Ï†ï
  useEffect(() => {
    if (!visible) return;

    let isComponentMounted = true;

    const setupWebSocket = () => {
      if (!isComponentMounted) return;

      console.log('üîÑ QueueDisplay - WebSocket Ïó∞Í≤∞ ÏÑ§Ï†ï');
      wsClient.connect();
      
      // Ïó∞Í≤∞ ÌõÑ Ï¶âÏãú ÎåÄÍ∏∞ Î™©Î°ù Ï°∞Ìöå
      fetchQueueList();
      
      return wsClient.addListener(handleWebSocketMessage);
    };

    const removeListener = setupWebSocket();

    return () => {
      console.log('üîå QueueDisplay - WebSocket Ï†ïÎ¶¨');
      isComponentMounted = false;
      if (removeListener) removeListener();
    };
  }, [visible, handleWebSocketMessage]);

  // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏/Ïñ∏ÎßàÏö¥Ìä∏ Ïãú ÎåÄÍ∏∞ Î™©Î°ù Ï°∞Ìöå
  useEffect(() => {
    if (visible) {
      console.log('üîÑ QueueDisplay - Ï¥àÍ∏∞ ÎåÄÍ∏∞ Î™©Î°ù Ï°∞Ìöå');
      fetchQueueList();
    }
  }, [visible]);

  // ÌïÑÌÑ∞ÎßÅÎêú Î™©Î°ù Í≥ÑÏÇ∞
  const getFilteredList = () => {
    if (!Array.isArray(queueList)) return [];  // Î∞∞Ïó¥Ïù¥ ÏïÑÎãê Í≤ΩÏö∞ Îπà Î∞∞Ïó¥ Î∞òÌôò
    
    return queueList
      .filter(patient => {
        if (!patient?.patientId?.basicInfo?.name || !patient?.queueNumber) return false;
        return (
          patient.patientId.basicInfo.name.includes(searchText) ||
          patient.queueNumber.includes(searchText)
        );
      })
      .filter(patient => {
        switch (activeTab) {
          case '2': return patient.status === 'waiting';
          case '3': return patient.status === 'called';
          case '4': return patient.status === 'consulting';
          default: return true;
        }
      });
  };

  const filteredList = getFilteredList();

  const handlePatientClick = (patient) => {
    setSelectedPatient(patient);
    setIsDrawerVisible(true);
  };

  const formatDate = (dateString) => {
    if (!dateString) return '-';
    return new Date(dateString).toLocaleString('ko-KR');
  };

  const handleSearch = (e) => {
    setSearchText(e.target.value);
  };

  // voices ÎåÄÏã† getVoices() Ìï®Ïàò ÏÇ¨Ïö©
  const availableVoices = getVoices();

  useEffect(() => {
    console.log('ÎåÄÍ∏∞ Î™©Î°ù Îç∞Ïù¥ÌÑ∞:', queueList);
  }, [queueList]);

  useEffect(() => {
    try {
      if (!isSpeechSynthesisSupported()) {
        console.warn('‚ö†Ô∏è ÏùåÏÑ± Ìï©ÏÑ± ÏßÄÏõê Ïïà Îê®');
        setIsVoiceEnabled(false);
        localStorage.setItem('queueVoiceEnabled', 'false');
        return;
      }

      if (lastCalledPatient?.patientId?.basicInfo?.name && isVoiceEnabled) {
        safeSpeak(`${lastCalledPatient.patientId.basicInfo.name}Îãò ÏßÑÎ£åÏã§Î°ú Îì§Ïñ¥Ïò§ÏÑ∏Ïöî.`);
      }
    } catch (e) {
      console.error('ÏùåÏÑ±Ìï©ÏÑ± Ï§ë Ïò§Î•ò:', e);
    }
  }, [lastCalledPatient, isVoiceEnabled]);

  // ÏùåÏÑ± Ìï©ÏÑ± ÏùåÏÑ± Î™©Î°ù Ï¥àÍ∏∞Ìôî (ÏµúÏ¥à 1Ìöå)
  useEffect(() => {
    if (isSpeechSynthesisSupported()) {
      window.speechSynthesis.getVoices(); // Ï¥àÍ∏∞Ìôî Ìä∏Î¶¨Í±∞
    }
  }, []);

  if (error) {
    return (
      <Modal
        title="Ïò§Î•ò"
        open={visible}
        onCancel={onClose}
      >
        <div className="error-message">
          {error}
          <Button onClick={fetchQueueList}>Îã§Ïãú ÏãúÎèÑ</Button>
        </div>
      </Modal>
    );
  }

  if (!isSpeechSynthesisSupported()) {
    console.warn('ÏùåÏÑ± Ìï©ÏÑ± ÏÇ¨Ïö© Î∂àÍ∞Ä');
  }

  return (
    <>
      <Modal
        title={
          <div className="modal-header">
            <span>ÎåÄÍ∏∞ ÌôòÏûê Î™©Î°ù</span>
            <div className="header-right">
              <span>Ï¥ù {filteredList.length}Î™Ö</span>
              <span>Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏</span>
              <div className="switch-group">
                <Switch 
                  size="small" 
                  checked={isRealtime}
                  onChange={setIsRealtime}
                />
                <Switch
                  size="small"
                  checked={isVoiceEnabled}
                  onChange={handleVoiceToggle}
                  disabled={!isSpeechSynthesisSupported()}
                />
                <Switch
                  size="small"
                  checked={isSoundEnabled}
                  onChange={handleSoundToggle}
                />
              </div>
            </div>
          </div>
        }
        open={visible}
        onCancel={onClose}
        width="500px"
        footer={null}
        styles={{
          body: { maxHeight: 'calc(100vh - 200px)', overflowY: 'auto' }
        }}
      >
        {!isSpeechSynthesisSupported() && (
          <Alert
            message="ÏùåÏÑ± ÏïàÎÇ¥ ÏßÄÏõê ÏïàÎê®"
            description="Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî ÏùåÏÑ± Ìï©ÏÑ±ÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§."
            type="warning"
            showIcon
            style={{ marginBottom: 16 }}
          />
        )}

        <div className="notification-bar">
          <span>üîä {lastCalledPatient && lastCalledPatient.status === 'called' && lastCalledPatient.patientId?.basicInfo?.name}Îãò ÏßÑÎ£åÏã§Î°ú ÏôÄÏ£ºÏÑ∏Ïöî</span>
          <span className="close">√ó</span>
        </div>

        <div className="tab-container">
          <Tabs 
            defaultActiveKey="1" 
            onChange={setActiveTab}
            items={[
              { label: 'Ï†ÑÏ≤¥', key: '1' },
              { label: 'ÎåÄÍ∏∞', key: '2' },
              { label: 'Ìò∏Ï∂ú', key: '3' },
              { label: 'ÏßÑÎ£åÏ§ë', key: '4' }
            ]}
          />

          <Input
            prefix={<SearchOutlined />}
            placeholder="Ïù¥Î¶Ñ ÎòêÎäî Î≤àÌò∏ Í≤ÄÏÉâ"
            className="search-input"
            value={searchText}
            onChange={handleSearch}
          />
        </div>

        <List
          loading={loading}
          dataSource={filteredList}
          locale={{ emptyText: 'ÎåÄÍ∏∞ ÌôòÏûêÍ∞Ä ÏóÜÏäµÎãàÎã§.' }}
          renderItem={(item) => {
            const statusInfo = STATUS_CONFIG[item.status] || STATUS_CONFIG.waiting;
            const isJustCalled = item._id === lastCalledPatient?._id;

            console.log(item.patientId?.basicInfo?.name, item.queueNumber, item.createdAt);

            return (
              <AnimatePresence mode="wait">
                <MotionCard
                  key={item._id}
                  isJustCalled={isJustCalled}
                  hoverable
                  onClick={() => handlePatientClick(item)}
                  variants={listItemVariants}
                  initial="hidden"
                  animate="visible"
                  exit="exit"
                  transition={{ type: "spring", stiffness: 300, damping: 30 }}
                >
                  <QueueItem>
                    <Space direction="vertical" size={2}>
                      <Space align="center">
                        <Title level={4} style={{ margin: 0 }}>
                          {item.patientId?.basicInfo?.name || 'Ïù¥Î¶Ñ ÏóÜÏùå'}
                        </Title>
                        <Text type="secondary">({item.queueNumber || '-'})</Text>
                      </Space>
                      <Space>
                        <Text type="secondary">
                          {item.patientId?.basicInfo?.visitType || '-'}
                        </Text>
                        <WaitingTime>
                          ÎåÄÍ∏∞ÏãúÍ∞Ñ: {calculateWaitingTime(item.createdAt)}
                        </WaitingTime>
                      </Space>
                    </Space>
                    <StatusBadge 
                      status={statusInfo.color} 
                      text={
                        <Space>
                          {statusInfo.icon}
                          {statusInfo.text}
                        </Space>
                      }
                    />
                  </QueueItem>
                </MotionCard>
              </AnimatePresence>
            );
          }}
        />

        <div className="pagination-info">
          Ï¥ù {filteredList.length}Í∞ú <span className="current-page">1</span> 10 / ÌéòÏù¥ÏßÄ
        </div>
      </Modal>

      <Drawer
        title="ÌôòÏûê ÏÉÅÏÑ∏ Ï†ïÎ≥¥"
        placement="right"
        onClose={() => setIsDrawerVisible(false)}
        open={isDrawerVisible}
        width={400}
      >
        {selectedPatient && (
          <>
            <Descriptions column={1} bordered>
              <Descriptions.Item label="Ïù¥Î¶Ñ">
                {selectedPatient.patientId?.basicInfo?.name || '-'}
              </Descriptions.Item>
              <Descriptions.Item label="Ïó∞ÎùΩÏ≤ò">
                <Space>
                  <PhoneOutlined />
                  {selectedPatient.patientId?.basicInfo?.phone || '-'}
                </Space>
              </Descriptions.Item>
              <Descriptions.Item label="Ï†ëÏàò ÏãúÍ∞Ñ">
                <Space>
                  <CalendarOutlined />
                  {formatDate(selectedPatient.createdAt)}
                </Space>
              </Descriptions.Item>
              <Descriptions.Item label="Î∞©Î¨∏ Ïú†Ìòï">
                {selectedPatient.patientId?.basicInfo?.visitType || '-'}
              </Descriptions.Item>
              <Descriptions.Item label="Ï£ºÏöî Ï¶ùÏÉÅ">
                <Space wrap>
                  {selectedPatient.patientId?.symptoms?.map((symptom, index) => (
                    <Tag key={index} color="blue">{symptom}</Tag>
                  )) || '-'}
                </Space>
              </Descriptions.Item>
              <Descriptions.Item label="Î≥µÏö© Ï§ëÏù∏ ÏïΩÎ¨º">
                <Space wrap>
                  {selectedPatient.patientId?.medications?.map((med, index) => (
                    <Tag key={index} color="purple" icon={<MedicineBoxOutlined />}>
                      {med}
                    </Tag>
                  )) || '-'}
                </Space>
              </Descriptions.Item>
            </Descriptions>
          </>
        )}
      </Drawer>
    </>
  );
};

export default QueueDisplay;
